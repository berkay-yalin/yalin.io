<!DOCTYPE html><html lang="en" data-astro-cid-xdrw2ewq> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v4.14.2"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://yalin.io/articles/big-o-notation/"><!-- Primary Meta Tags --><title>Big O notation</title><meta name="title" content="Big O notation"><meta name="description" content="An introduction to big o notation in computer science"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://yalin.io/articles/big-o-notation/"><meta property="og:title" content="Big O notation"><meta property="og:description" content="An introduction to big o notation in computer science"><meta property="og:image" content="https://yalin.io/articles/big-o-notation/.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://yalin.io/articles/big-o-notation/"><meta property="twitter:title" content="Big O notation"><meta property="twitter:description" content="An introduction to big o notation in computer science"><meta property="twitter:image" content="https://yalin.io/articles/big-o-notation/.jpg"><style>nav[data-astro-cid-pux6a34n]{display:flex;justify-content:end;gap:1rem;padding:1rem;box-sizing:border-box}a[data-astro-cid-pux6a34n]{color:gray;text-decoration:none}a[data-astro-cid-pux6a34n]:hover{cursor:pointer;color:#fff}
*{color:#fff}a{color:#58a6ff}.katex-html{display:none!important}h1{font-size:2rem}h2{font-size:1.75rem}h3{font-size:1.5rem}h4{font-size:1.25rem}p:has(img){display:flex;justify-content:center;width:100%}p:has(img) img{max-width:100%;background-color:#fff}table{margin:auto}blockquote *{color:#d3d3d3}a:has(sup){text-decoration:none}sup{color:inherit;text-decoration:none}.red{color:red}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-regular.woff) format("woff");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-bold.woff) format("woff");font-weight:700;font-style:normal;font-display:normal}html,body{font-family:Atkinson,sans-serif;margin:0;padding:0}html,body{background-color:#111}article[data-astro-cid-xdrw2ewq]{max-width:720px;margin:auto;padding:1rem;box-sizing:border-box}.hero-wrapper[data-astro-cid-xdrw2ewq]{margin:auto;text-align:center}.date[data-astro-cid-xdrw2ewq]{font-size:.9rem}.title[data-astro-cid-xdrw2ewq]{font-size:1rem}
</style></head> <body data-astro-cid-xdrw2ewq> <nav data-astro-cid-pux6a34n> <a href="/projects" data-astro-cid-pux6a34n>projects</a> <a href="/articles" data-astro-cid-pux6a34n>articles</a> <a href="https://github.com/berkay-yalin" target="_blank" data-astro-cid-pux6a34n>github</a> </nav>  <main data-astro-cid-xdrw2ewq> <article data-astro-cid-xdrw2ewq> <div class="hero-wrapper" data-astro-cid-xdrw2ewq> <div class="date" data-astro-cid-xdrw2ewq>Monday, October 7, 2024</div> <div class="title" data-astro-cid-xdrw2ewq>Big O notation</div> </div>  <h1 id="big-o-notation">Big O Notation</h1>
<h2 id="tldr">tldr</h2>
<ul>
<li>
<p><strong>Big O notation</strong> is used to classify the behaviour of an algorithm’s time or space complexity relative to the input size.</p>
</li>
<li>
<p>The <strong>time complexity</strong> is defined by the number of operations performed by an algorihtm relative to the size of the input.</p>
</li>
<li>
<p>The <strong>space complexity</strong> is defined by the amount of memory required by an algorithm relative to the size of the input.</p>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Many algorithms in programming, like functions for example, can have data passed into them in the form of an argument. <strong>Big O notation</strong>, presented in the form of a function, is used to describe the efficiency of an algorithm as the size of its input grows.</p>
<p>Now there are two metrics for which big o notation measures, <strong>time complexity</strong> and <strong>space complexity</strong>:</p>
<ul>
<li>
<p>The <strong>time complexity</strong> is defined by the number of operations performed by an algorihtm relative to the size of the input.</p>
</li>
<li>
<p>The <strong>space complexity</strong> is defined by the amount of memory required by an algorithm relative to the size of the input.</p>
</li>
</ul>
<p>stop reading</p>
<p>The function $O$ takes an argument representing the growth rate of the time or space complexity relative to the input size $n$.</p>
<p>Many algorithms in programming, like functions for example, can have data passed into them in the form of an argument. <strong>Big O notation</strong>, presented in the form of a function, is used to describe the efficiency of an algorithm as the size of its input grows. The function $O$ takes an argument representing the growth rate of the time or space complexity relative to the input size $n$.</p>
<p>STOP READING</p>
<p>manipulate the and usually end up returning another value.</p>
<p><strong>Big O notation</strong> is used to describe the the efficiency of an algorithm as the size of its input grows.</p>
<p><strong>Big O notation</strong> is used to classify the behaviour of an algorithm’s time or space complexity relative to the input size.</p>
<p>But what does this actually mean?</p>
<p>The function $O$ takes an argument representing the growth rate of the time or space complexity relative to the input size $n$.</p>
<p>todo: the examples mean nothing introduction paragraph is not understandable</p>
<h2 id="whats-even-going-on">What’s even going on?</h2>
<p>Whilst Wikipedia describes <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a> as something “used to classify algorithms according to how their run time or space requirements grow as the input size grows”, this doesn’t really mean much to a beginner. Now time complexity is defined as the “amount of computer time it takes to run an algorithm”, but surely this doesn’t really mean anything as different computers have different clock speeds? Well, yes and no. On the surface these definitions might appear to make no sense, but hopefully by the end of this article you will have a strong understanding for the basics of big o notation and how it is used to classify computer algorithms.</p>
<h2 id="definitions">Definitions</h2>
<ul>
<li>
<p><strong>Big O notation</strong> is used to classify the behaviour of an algorithm’s time or space complexity relative to the input size.</p>
</li>
<li>
<p>The <strong>time complexity</strong> is defined by the number of operations performed by an algorihtm relative to the size of the input.</p>
</li>
<li>
<p>The <strong>space complexity</strong> is defined by the amount of memory required by an algorithm relative to the size of the input.</p>
</li>
</ul>
<p>Now to understand what all this means, lets understand the notation and go through a few examples.</p>
<h2 id="notation">Notation</h2>
<p>The function $O$ takes an argument representing the growth rate of the time or space complexity relative to the input size $n$. The growth rate is “chosen to be as simple as possible, omitting constant factors and lower order terms”. <a href="https://en.wikipedia.org/wiki/Big_O_notation">[1]</a></p>
<p>For example, $O(n)$ represents a linear growth rate, signifying that the complexity is directly proportional to the input size.</p>
<p>Let’s run through a few examples to get a clear idea how this is applied.</p>
<h2 id="examples">Examples</h2>
<h3 id="example-1">Example 1</h3>
<p>For example, for a constant time complexity $O(1)$, an algorithm would always perform the same number of operations regardless of the input size.</p>
<p>todo: why is it a 1?</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> get_first_element</span><span style="color:#E1E4E8">(array):</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> array[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span></code></pre>
<h3 id="example-2">Example 2</h3>
<p>Now for a linear time complexity $O(n)$, the number of operations increases directly in proportion to the size of the input.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> get_sum_of_elements</span><span style="color:#E1E4E8">(array):</span></span>
<span class="line"><span style="color:#E1E4E8">    total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> array:</span></span>
<span class="line"><span style="color:#E1E4E8">        total </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> i</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> total</span></span>
<span class="line"></span></code></pre>
<p>But wait a minute? Whilst the for loop might run once for each element in <code>array</code>, what about the lines <code>total = 0</code> and <code>return total</code>? Shouldn’t this algorithm be something like $O(1) + O(n) + O(1)$?</p>
<p>Well, yes and no.</p>
<p>Lets break it down.</p>
<p>The lines <code>total = 0</code> and <code>return total</code> have a constant time complexity, as regardless of the number of elements in <code>array</code>, the same number of operations will occur. On the other hand, the for loop will run once for each element in <code>array</code>. If the array has an input size of 10, then the for loop will execute 10 times, meaning it has a linear time complexity.</p>
<p>Remember that the growth rate omits constant factors and lower order terms, so the time complexity is $O(n)$ for this algorithm.</p>
<h3 id="example-3">Example 3</h3>
<p>hello world</p>  </article> </main>  </body></html>